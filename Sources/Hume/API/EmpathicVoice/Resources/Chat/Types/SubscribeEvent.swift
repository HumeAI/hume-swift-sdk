//
//  SubscribeEvent.swift
//
//
//  This file was auto-generated by Fern from our API Definition.
//

import Foundation


public enum SubscribeEvent: Decodable {
    case assistantEnd(AssistantEnd)
    case assistantMessage(AssistantMessage)
    case assistantProsodyMessage(AssistantProsodyMessage)
    case audioOutput(AudioOutput)
    case chatMetadata(ChatMetadata)
    case webSocketError(WebSocketError)
    case userInterruption(UserInterruption)
    case userMessage(UserMessage)
    case toolCallMessage(ToolCallMessage)
    case toolResponseMessage(ToolResponseMessage)
    case toolErrorMessage(ToolErrorMessage)
    
    
    private enum CodingKeys: String, CodingKey {
        case type
    }
    
    var debugName: String {
        switch self {
        case .assistantEnd:
            return "assistant_end"
        case .assistantMessage:
            return "assistant_message"
        case .assistantProsodyMessage:
            return "assistant_prosody"
        case .audioOutput:
            return "audio_output"
        case .chatMetadata:
            return "chat_metadata"
        case .webSocketError:
            return "web_socket_error"
        case .userInterruption:
            return "user_interruption"
        case .userMessage:
            return "user_message"
        case .toolCallMessage:
            return "tool_call"
        case .toolResponseMessage:
            return "tool_response"
        case .toolErrorMessage:
            return "tool_error"
        }
    }
    
    
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let type = try container.decode(String.self, forKey: .type)
        Logger.debug("Decoding event of type=\(type)")

        switch type {
        case "assistant_end":
            self = .assistantEnd(try AssistantEnd(from: decoder))
        case "assistant_message":
            self = .assistantMessage(try AssistantMessage(from: decoder))
        case "assistant_prosody":
            self = .assistantProsodyMessage(try AssistantProsodyMessage(from: decoder))
        case "audio_output":
            self = .audioOutput(try AudioOutput(from: decoder))
        case "chat_metadata":
            self = .chatMetadata(try ChatMetadata(from: decoder))
        case "error":
            self = .webSocketError(try WebSocketError(from: decoder))
        case "user_interruption":
            self = .userInterruption(try UserInterruption(from: decoder))
        case "user_message":
            self = .userMessage(try UserMessage(from: decoder))
        case "tool_call":
            self = .toolCallMessage(try ToolCallMessage(from: decoder))
        case "tool_response":
            self = .toolResponseMessage(try ToolResponseMessage(from: decoder))
        case "tool_error":
            self = .toolErrorMessage(try ToolErrorMessage(from: decoder))
        default:
            throw HumeError.invalidType(type)
        }
    
    }
}
