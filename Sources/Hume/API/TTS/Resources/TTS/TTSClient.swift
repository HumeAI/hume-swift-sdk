// This file is generated by generator.ts

import Foundation

public class TTS {

  private let options: HumeClient.Options

  init(options: HumeClient.Options) {
    self.options = options
  }

  public func synthesizeJson(
    post_usage: Bool?, access_token: String?, request: PostedTts
  ) async throws -> ReturnTts {
    guard var urlComponents = URLComponents(string: "https://\(self.options.base)/v0/tts") else {
      throw URLError(.badURL)
    }

    guard let url = urlComponents.url else {
      throw URLError(.badURL)
    }

    var req = URLRequest(url: url)
    req.httpMethod = "POST"
    req.setValue(self.options.apiKey, forHTTPHeaderField: "X-Hume-Api-Key")
    req.setValue("application/json", forHTTPHeaderField: "Content-Type")

    // Prepare request body if needed
    if true {
      var requestBody: [String: Any] = [:]
      requestBody["request"] = request
      req.httpBody = try JSONSerialization.data(withJSONObject: requestBody)
    }

    let session = URLSession(configuration: .default)
    let (data, _) = try await session.data(for: req)

    return try Defaults.decoder.decode(ReturnTts.self, from: data)
  }

  public func synthesizeFile(
    access_token: String?, request: PostedTts
  ) async throws -> Data {
    guard var urlComponents = URLComponents(string: "https://\(self.options.base)/v0/tts/file")
    else {
      throw URLError(.badURL)
    }

    guard let url = urlComponents.url else {
      throw URLError(.badURL)
    }

    var req = URLRequest(url: url)
    req.httpMethod = "POST"
    req.setValue(self.options.apiKey, forHTTPHeaderField: "X-Hume-Api-Key")
    req.setValue("application/json", forHTTPHeaderField: "Content-Type")

    // Prepare request body if needed
    if true {
      var requestBody: [String: Any] = [:]
      requestBody["request"] = request
      req.httpBody = try JSONSerialization.data(withJSONObject: requestBody)
    }

    let session = URLSession(configuration: .default)
    let (data, _) = try await session.data(for: req)

    return data
  }

  public func synthesizeFileStreaming(
    access_token: String?, request: PostedTts
  ) async throws -> Data {
    guard
      var urlComponents = URLComponents(string: "https://\(self.options.base)/v0/tts/stream/file")
    else {
      throw URLError(.badURL)
    }

    guard let url = urlComponents.url else {
      throw URLError(.badURL)
    }

    var req = URLRequest(url: url)
    req.httpMethod = "POST"
    req.setValue(self.options.apiKey, forHTTPHeaderField: "X-Hume-Api-Key")
    req.setValue("application/json", forHTTPHeaderField: "Content-Type")

    // Prepare request body if needed
    if true {
      var requestBody: [String: Any] = [:]
      requestBody["request"] = request
      req.httpBody = try JSONSerialization.data(withJSONObject: requestBody)
    }

    let session = URLSession(configuration: .default)
    let (data, _) = try await session.data(for: req)

    return data
  }

  public func synthesizeJsonStreaming(
    access_token: String?, request: PostedTts
  ) async throws -> SnippetAudioChunk {
    guard
      var urlComponents = URLComponents(string: "https://\(self.options.base)/v0/tts/stream/json")
    else {
      throw URLError(.badURL)
    }

    guard let url = urlComponents.url else {
      throw URLError(.badURL)
    }

    var req = URLRequest(url: url)
    req.httpMethod = "POST"
    req.setValue(self.options.apiKey, forHTTPHeaderField: "X-Hume-Api-Key")
    req.setValue("application/json", forHTTPHeaderField: "Content-Type")

    // Prepare request body if needed
    if true {
      var requestBody: [String: Any] = [:]
      requestBody["request"] = request
      req.httpBody = try JSONSerialization.data(withJSONObject: requestBody)
    }

    let session = URLSession(configuration: .default)
    let (data, _) = try await session.data(for: req)

    return try Defaults.decoder.decode(SnippetAudioChunk.self, from: data)
  }

}
