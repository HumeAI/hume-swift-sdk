import { $, ShellError } from "bun";
import _ from "lodash";
import { assert } from "console";
import * as OA from "./parse_openapi";
import type { JsonSchema } from "./parse_openapi";
import fs from "fs/promises";
import { camelCase, pascalCase } from 'change-case';


const GENERATION_HEADER = "// This file is generated by generator.ts";
// Usage: [1, null, 3].filter(outNulls)
const outNulls = <T>(obj: T): obj is NonNullable<T> => {
  return Boolean(obj);
};

type Verb = "get" | "post" | "put" | "patch" | "delete";

const exhaustive = (x: never): any => x;

type File = {
  path: string;
  content: string;
};

type SwiftType =
  | { type: "Int" }
  | { type: "Float" }
  | { type: "Double" }
  | { type: "Bool" }
  | { type: "String" }
  | { type: "Optional"; wrapped: SwiftType }
  | { type: "Array"; element: SwiftType }
  | { type: "Reference"; name: string }
  | { type: "Dictionary"; key: SwiftType; value: SwiftType }
  | { type: "void" }
  | { type: "Data" }
  | { type: "TODO"; message: string };

const walkSwiftType = (type: SwiftType, f: (type: SwiftType) => void) => {
  f(type);
  switch (type.type) {
    case "Int":
    case "Float":
    case "Double":
    case "Bool":
    case "String":
    case "TODO":
      return;
    case "Optional":
      f(type.wrapped);
      return;
    case "Array":
      f(type.element);
      return;
    case "Reference":
      return;
    case "Dictionary":
      f(type.value);
      return;
  }
};

const hasTodo = (type: SwiftType): boolean => {
  let result = false;
  walkSwiftType(type, (t) => {
    if (t.type === "TODO") {
      result = true;
    }
  });
  return result;
};

type SwiftStruct = {
  type: "struct";
  name: string;
  properties: Array<{ name: string; type: SwiftType; docstring?: string }>;
  codingKeys: Array<[string, string]>;
};

type SwiftEnum = {
  type: "enum";
  name: string;
  members: Array<[string, string]>;
};

type SwiftDiscriminatedUnion = {
  type: "discriminatedUnion";
  name: string;
  discriminator: string;
  cases: Array<{ caseName: string; type: SwiftType }>;
};

type SwiftDefinition = SwiftStruct | SwiftEnum | SwiftDiscriminatedUnion;

type SDKMethodParam = {
  name: string;
  type: SwiftType;
  in: "path" | "query" | "body";
  defaultValue?: string;
};
type SDKMethod = {
  name: string;
  verb: "get" | "post" | "put" | "patch" | "delete";
  path: string;
  parameters: Array<SDKMethodParam>;
  returnType: SwiftType;
};


// kebab-case to PascalCase
const normalizeResourceName = (resourceName: string) => {
  return pascalCase(resourceName.replace(/-/g, ' '));
};

// gets rid of some square brackets that appear in the tts api
const normalizeObjectName = (title: string) => {
  return pascalCase(title.replace(/\[.*\]/, ""));
};

const normalizePropertyName = (propertyName: string) => {
  // Replace /, *, (, ), or - with underscores
  // trim leading or trailing underscores
  // convert to camel case
  return camelCase(
    propertyName.replace(/\/|\*|-|\(|\)| /g, "_").replace(/^_+|_+$/g, ""),
  );
};

const normalizedEnumNameFromValue = (enumValue: string, enumName: string) => {
  // Replace /, *, ., or - with underscores
  // trim leading or trailing underscores
  // convert to camel case
  // If the enum value begins with a number, prefix it with an underscore
  let name = enumValue;
  name = name.replace(/\/|\*|-|\(|\)/g, "_");
  name = name.replace(/\./g, "_");
  name = name.replace(/^_+|_+$/g, "");
  if (name.match(/^[0-9]/)) {
    name = "_" + name;
  }
  name = camelCase(name);

  if (/^([0-9]+)/.test(name)) {
    name = `${pascalCase(enumName)}_` + name;
  }
  return name;
};

type UnIgnored<T> = T extends { kind: "ignored" } ? never : T;


const getMethodName = (operation: UnIgnored<OA.OpenAPIOperation>): string => {
  if (operation["x-fern-sdk-method-name"]) {
    return camelCase(operation["x-fern-sdk-method-name"]);
  }

  // Fallback to operationId if available
  if (operation.operationId) {
    return camelCase(operation.operationId);
  }
  
  // If no operationId, throw an exception - missing operationId is a serious issue
  throw new Error("Missing operationId in OpenAPI operation");
};

/**
 * This `Back` infrastructure is for keeping track of where you came from as you traverse a schema.
 * This is needed: suppose you have an object like
 *
 * Foo {
 *   bar: {
 *     baz: ['a' | 'b' | 'c']
 *   }
 * }
 *
 * This will need a Swift enum like
 * enum Baz {
 *   case a
 *   case b
 *   case c
 * }
 * but how do we know the enum should be called `Baz`? We need to know that
 * we're inside an array that is inside property called `baz`. So we need to
 * a trail "back" into outer schemas in order to ask questions like this.
 */
type Back<T, TStep> = {
  /** to is the schema we are pointing back *to* e.g. the outer schema that surrounds us */
  to: T;
  /** step is *how* `to` surrounds us. Are we a property inside an object? Are we an element inside an array? */
  step: TStep;
  /** back is the rest of the trail, back from `to`. null if we are at the root */
  back: Back<T, TStep> | null;
};

type Step =
  | {
    kind: "property";
    name: string;
  }
  | {
    kind: "nullable";
  }
  | {
    kind: "variant";
    i: number;
  }
  | {
    kind: "array";
  };

const surroundingPropertyName = (
  back: Back<JsonSchema, Step> | null,
): string | null => {
  if (!back) {
    return null;
  }
  if (back.step.kind === "property") {
    return back.step.name;
  }
  return surroundingPropertyName(back.back);
};


const swiftName = (schema: JsonSchema, surroundingName?: string): string => {
  // Handle ignored schema kind
  if (schema.kind === 'ignored') {
    return "TODO_IGNORED_TYPE";
  }
  
  if (schema.kind === 'enum') {
    const result = schema["x-fern-type-name"] ?? schema.title ?? schema.schemaKey ?? surroundingName;
    if (!result) {
      // For the specific HUME_AI, CUSTOM_VOICE enum, use a TODO name to help identify it
      if (schema.enum && 
          schema.enum.length === 2 && 
          schema.enum.includes("HUME_AI") && 
          schema.enum.includes("CUSTOM_VOICE")) {
        console.warn("Using TODO_VOICE_PROVIDER name for unnamed enum with HUME_AI and CUSTOM_VOICE values");
        return "TODO_VOICE_PROVIDER";
      }
      
      // Log details but return a TODO name to help identify where this is used
      console.warn("Using TODO name for unnamed enum with values:", schema.enum);
      return "TODO_UNNAMED_ENUM";
    }
    return result
  }
  if (schema.kind === 'object') {
    const result = schema["x-fern-type-name"] ??
      schema.title ?? schema.schemaKey ??
      "TODO_OBJECT_HAD_NO_NAME"
    return normalizeObjectName(result)
  }
  if (schema.kind === 'discriminatedUnion') {
    return schema.title ? schema.title : "TODO_DISCRIMINATED_UNION_HAD_NO_NAME";
  }
  
  // For any other kinds of schemas, use a TODO name to make it stand out in generated code
  console.warn(`Using TODO name for schema of kind ${schema.kind}`);
  return `TODO_${schema.kind.toUpperCase()}_TYPE`;
}
/**
 * Takes a JsonSchema and converts it to a SwiftType `expr`.
 * If the schema is a reference or contains references to
 * types that translate to enums or structs, it will recurse
 * appropriately and these definitions will wind up in `defs`.
 */
const schemaToSwiftType = (
  schema: JsonSchema,
  allSchemas: Record<string, JsonSchema>,
  back: null | Back<JsonSchema, Step> = null,
): { expr: SwiftType; defs: Record<string, SwiftDefinition> } => {
  const recurse = (
    schema: JsonSchema,
    step: Step,
  ): ReturnType<typeof schemaToSwiftType> => {
    return schemaToSwiftType(schema, allSchemas, {
      step,
      to: schema,
      back,
    });
  };
  const result = (
    expr: SwiftType,
    defs: Record<string, SwiftDefinition> = {},
  ) => ({
    expr,
    defs,
  });
  const todo = (message: string) => result({ type: "TODO", message });

  switch (schema.kind) {
    case "ignored": {
      throw new Error();
    }
    case "empty":
    case "inheritance":
      return todo("inheritance not supported yet");
    case "unionOfRefs":
      return todo("unionOfRefs not supported yet");
    case "ref":
      const lookedUp = lookupSchemaRef(schema.$ref, allSchemas);
      return { expr: { type: "Reference", name: swiftName(lookedUp) }, defs: {} };
  }

  if (schema.nullable) {
    const { expr, defs } = recurse(
      { ...schema, nullable: false },
      { kind: "nullable" },
    );
    return result({ type: "Optional", wrapped: expr }, defs);
  }

  switch (schema.kind) {
    case "discriminatedUnion": {
      const unionName = swiftName(schema)
      const discriminator = schema.discriminator;
      const defs = {};
      const cases = schema.oneOf.map(
        (option, i): SwiftDiscriminatedUnion["cases"][number] => {
          const todoCase = (
            message: string,
          ): SwiftDiscriminatedUnion["cases"][number] => ({
            type: todo(message).expr,
            caseName: "todo",
          });
          if (option.kind !== "object") {
            return todoCase(
              "Unexpected: non-object inside discriminated union oneOf",
            );
          }
          if (!option.title) {
            return todoCase(
              "Unexpected: untitled object in discriminated union oneOf",
            );
          }
          const { expr, defs: theseDefs } = recurse(option, {
            kind: "variant",
            i,
          });
          Object.assign(defs, theseDefs);
          return { caseName: option.title, type: expr };
        },
      );
      const unionDef: SwiftDiscriminatedUnion = {
        type: "discriminatedUnion",
        name: unionName,
        discriminator: discriminator.propertyName,
        cases,
      };
      return result(
        { type: "Reference", name: unionName },
        { [unionName]: unionDef },
      );
    }
    case "anyOfDiscriminatedUnion":
      return todo("anyOfDiscriminatedUnion not supported yet");
    case "anyOfUndiscriminatedUnion":
      return todo("anyOfUndiscriminatedUnion not supported yet");
    case "oneOfUndiscriminatedUnion":
      return todo("oneOfUundiscriminatedUnion not supported yet");
    case "singletonOrArray":
      return todo("singletonOrArray not supported yet");
    case "metadataObject":
      return todo("metadataObject not supported yet");
    case "enum": {
      const enumName = swiftName(schema, surroundingPropertyName(back)!);
      if (!enumName) {
        // Just throw in this case, hopefully we can avoid it.
        // If it ever surfaces in a way where there is no name, we should either override the
        // api spec to add a title (ideal), or default to 'string'.
        console.error(schema, back);
        throw new Error(`Could not calculate name for enum`);
      }
      const members = schema.enum.map(
        (value) =>
          [normalizedEnumNameFromValue(value, enumName), value] as [string, string],
      );
      const enumDef: SwiftEnum = {
        type: "enum",
        name: enumName,
        members,
      };
      return result(
        { type: "Reference", name: enumName },
        { [enumName]: enumDef },
      );
    }
    case "primitive": {
      switch (schema.type) {
        case "string":
          return result({ type: "String" });
        case "number":
          return result({ type: "Double" });
        case "integer":
          return result({ type: "Int" });
        case "boolean":
          return result({ type: "Bool" });
      }
    }
    case "stringOrInteger":
      return todo("stringOrInteger not implemented yet");
    case "stringNumberBool":
      return todo("stringNumberBool not implemented yet");
    case "object": {
      const name = swiftName(schema);
      const defs: Record<string, SwiftDefinition> = {};
      const rawProperties: Array<{ name: string; type: SwiftType }> =
        Object.entries(schema.properties)
          .map(([name, prop]): { name: string; type: SwiftType } | null => {
            if (prop.kind === "ignored") {
              return null;
            }
            
            // Add logging to debug the issue
            const resolved = resolveIfRef(prop, allSchemas);
            if (!resolved) {
              console.error(`Failed to resolve property reference:`, prop);
              return null;
            }
            
            if (resolved.kind === 'unionOfRefs') {
              return null
            }
            const { expr: type, defs: propertyDefs } = recurse(prop, {
              kind: "property",
              name,
            });
            Object.assign(defs, propertyDefs);
            return { name: camelCase(name), type };
          })
          .filter(outNulls);

      const properties = rawProperties.filter(p => p.name !== "TODO");
      const codingKeys = properties.map(({ name }): [string, string] => [normalizePropertyName(name), name]);
      // Filter out coding keys that don't match properties
      const matchingKeys = codingKeys.filter(([prop, _]) => properties.some(p => p.name === prop));
      const struct: SwiftStruct = {
        type: "struct",
        name,
        properties,
        codingKeys: matchingKeys,
      };
      defs[name] = struct;
      return result({ type: "Reference", name: struct.name }, defs);
    }
    case "array": {
      const { expr: element, defs } = recurse(schema.items, { kind: "array" });
      return result({ type: "Array", element }, defs);
    }
    case "dictionary":
      return todo(schema.kind + " not implemented yet");
  }
  return exhaustive(schema);
};

const lookupSchemaRef = (
  ref: string,
  schemas: Record<string, JsonSchema>,
): JsonSchema => {
  if (ref.startsWith("#/components/schemas/")) {
    return schemas[ref.replace(/^#\/components\/schemas\//, "")];
  }
  throw new Error(`Unknown ref: ${ref}`);
};

const resolveIfRef = (schema: JsonSchema, schemas: Record<string, JsonSchema>): JsonSchema => {
  if (!schema) {
    console.warn("Warning: Attempted to resolve undefined schema reference");
    // Return a placeholder schema to prevent crashes
    return { kind: "ignored" };
  }
  
  if (schema.kind === "ref") {
    return lookupSchemaRef(schema.$ref, schemas);
  }
  return schema
}

const openapiOperationToSDKMethod = (
  path: string,
  verb: Verb,
  op: OA.OpenAPIOperation,
  allSchemas: Record<string, JsonSchema>,
): SDKMethod | null => {
  if (op.kind === "ignored") {
    return null;
  }
  const specParameters = op.parameters ?? [];
  const sdkParameters: Array<SDKMethodParam> = [];
  sdkParameters.push(
    ...specParameters
      .filter((p) => p.in === "path")
      .map((p) => p.name)
      .map(
        (name): SDKMethodParam => ({
          name,
          type: { type: "String" },
          in: "path",
        }),
      ),
  );

  sdkParameters.push(
    ...specParameters
      .filter((p) => p.in === "query")
      .map((p): SDKMethodParam => {
        const { expr } = schemaToSwiftType(p.schema, allSchemas);
        let type = expr;
        if (!p.required) type = { type: "Optional", wrapped: type };
        return { name: p.name, type, in: "query" };
      }),
  );

  if (op.kind === "jsonBody") {
    const bodyStructName = swiftName(resolveIfRef(op.requestBody.content["application/json"].schema, allSchemas));
    sdkParameters.push({
      name: "request",
      type: { type: "Reference", name: bodyStructName },
      in: "body",
    });
  }

  const maybeSchemaOfStatus = (code: string): JsonSchema | null => {
    const response = op?.responses?.[code];
    if (!response) {
      return null;
    }
    if (response.kind === "jsonResponse") {
      return response.content["application/json"].schema;
    }
    if (response.kind === "binaryResponse") {
      return response.content["audio/*"].schema;
    }
    return null;
  };

  const isBinaryResponse = (code: string): boolean => {
    const response = op?.responses?.[code];
    return !!response && response.kind === "binaryResponse";
  };
  const successResponseSchema =
    maybeSchemaOfStatus("200") ??
    maybeSchemaOfStatus("201") ??
    maybeSchemaOfStatus("204");

  let returnType: SwiftType;
  if (isBinaryResponse("200") || isBinaryResponse("201")) {
    returnType = { type: "Data" };
  } else {
    const { expr } = successResponseSchema
      ? schemaToSwiftType(successResponseSchema, allSchemas)
      : { expr: { type: "void" as const } };
    returnType = expr;
  }

  return {
    name: getMethodName(op),
    path,
    verb,
    parameters: sdkParameters,
    returnType,
  };
};

const renderSwiftType = (type: SwiftType): string => {
  switch (type.type) {
    case "Int":
      return "Int";
    case "Float":
      return "Float";
    case "Double":
      return "Double";
    case "Bool":
      return "Bool";
    case "String":
      return "String";
    case "Optional":
      return `${renderSwiftType(type.wrapped)}?`;
    case "Array":
      return `[${renderSwiftType(type.element)}]`;
    case "Reference":
      return type.name;
    case "Dictionary":
      return `[String: ${renderSwiftType(type.value)}]`;
    case "void":
      return "Void";
    case "Data":
      return "Data";
    case "TODO":
      return "TODO";
  }
};
const renderSwiftEnum = (def: SwiftEnum): string => {
  return `
    public enum ${def.name}: String, Codable {
      ${def.members.map(([name, value]) => `case ${name} = "${value}"`).join("\n")}
    }
    `;
};

const renderSwiftDiscriminatedUnion = (
  def: SwiftDiscriminatedUnion,
): string => {
  // Each case becomes an enum case with an associated value.
  const cases = def.cases
    .map(({ caseName, type }) => `case ${caseName}(${renderSwiftType(type)})`)
    .join("\n    ");

  return `
public enum ${def.name}: Codable {
    ${cases}
    
    private enum CodingKeys: String, CodingKey {
        case ${def.discriminator}
    }
    
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let typeValue = try container.decode(String.self, forKey: .${def.discriminator})
        switch typeValue {
        ${def.cases
      .map(
        ({ caseName, type }) =>
          `case "${caseName}": self = .${caseName}(try ${renderSwiftType(type)}(from: decoder))`,
      )
      .join("\n        ")}
        default:
            throw DecodingError.dataCorruptedError(forKey: .${def.discriminator}, in: container, debugDescription: "Unexpected type value: \\(typeValue)")
        }
    }
    
    public func encode(to encoder: Encoder) throws {
        // Implement encoding logic as needed.
    }
}
`;
};

const renderSwiftStruct = (struct: SwiftStruct) => {
  const filteredProperties = struct.properties.filter(p => !hasTodo(p.type));
  const filteredCodingKeys = struct.codingKeys.filter(([key, _]) =>
    filteredProperties.some(p => p.name === key)
  );

  return `public struct ${struct.name}: Codable {
    ${filteredProperties
      .map((prop) => `  public let ${prop.name}: ${renderSwiftType(prop.type)}`)
      .join("\n")}
    enum CodingKeys: String, CodingKey {
      ${filteredCodingKeys.map(([key, value]) => `case ${key} = "${value}"`).join("\n")}
    }
}`;
};
const renderSwiftDefinition = (
  namespaceName: string,
  def: SwiftDefinition,
): File => {
  const path = `/Sources/Hume/API/${namespaceName}/Models/${def.name}.swift`;
  if (def.type === "enum") {
    return {
      path,
      content: renderSwiftEnum(def),
    };
  }
  if (def.type === "struct") {
    return {
      path,
      content: renderSwiftStruct(def),
    };
  }
  if (def.type === "discriminatedUnion") {
    return {
      path,
      content: renderSwiftDiscriminatedUnion(def),
    };
  }
  return exhaustive(def);
};

const renderSDKMethod = (method: SDKMethod): string => {
  const methodName = method.name;
  const renderedParams = method.parameters
    .map(({ name, type, defaultValue }) => {
      if (!defaultValue) {
        return `${name}: ${renderSwiftType(type)}`;
      }
      return `${name}: ${renderSwiftType(type)} = ${defaultValue}`;
    })
    .join(", ");
  let queryParamAdds = "";
  if (method.verb === "get") {
    queryParamAdds = `var queryItems: [URLQueryItem] = []\n`;
    method.parameters
      .filter((p) => p.in === "query")
      .forEach((p) => {
        queryParamAdds += `if let ${p.name} = ${p.name} {\n`;
        queryParamAdds += `queryItems.append(URLQueryItem(name: "${p.name}", value: String(${p.name})))\n`;
        queryParamAdds += `}\n`;
      });
    queryParamAdds += `urlComponents.queryItems = queryItems\n`;
  }
  return `
    public func ${methodName}(
      ${renderedParams}
    ) async throws -> ${renderSwiftType(method.returnType)} {
        guard var urlComponents = URLComponents(string: "https://\\(self.options.base)${method.path}") else {
            throw URLError(.badURL)
        }

        ${queryParamAdds}

        guard let url = urlComponents.url else {
            throw URLError(.badURL)
        }

        var req = URLRequest(url: url)
        req.httpMethod = "${method.verb.toUpperCase()}"
        req.setValue(self.options.apiKey, forHTTPHeaderField: "X-Hume-Api-Key")
        req.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        // Prepare request body if needed
        if (${method.parameters.filter(p => p.in === 'body').length > 0}) {
          var requestBody: [String: Any] = [:]
          ${method.parameters.filter(p => p.in === 'body').map(p => `requestBody["${p.name}"] = ${p.name}`).join('\n          ')}
          req.httpBody = try JSONSerialization.data(withJSONObject: requestBody)
        }

        let session = URLSession(configuration: .default)
        let (data, _) = try await session.data(for: req)

        ${method.returnType.type === "Data" ?
      "return data" :
      method.returnType.type === "void" ?
        "return ()" :
        `return try Defaults.decoder.decode(${renderSwiftType(method.returnType)}.self, from: data)`
    }
    }
    `;
};

const swiftFormat = async (input: string): Promise<string> => {
  const buf = Buffer.from(input);
  try {
    return await $`swift format < ${buf}`.text();
  } catch (e: unknown) {
    const inputNumbered = input
      .split("\n")
      .map((line, i) => `${i + 1}: ${line}`)
      .join("\n");
    const errorOutput = (e as ShellError).stderr.toString();
    throw new Error(
      `Error formatting swift code:\n${inputNumbered}\n${errorOutput}`,
    );
  }
};

const renderNamespaceClient = (
  namespaceName: string,
  resourceNames: string[],
): File => {
  return {
    path: `/Sources/Hume/API/${namespaceName}/Client/${namespaceName}Client.swift`,
    content: `
    import Foundation
    
    public class ${pascalCase(namespaceName)} {
        
        private let options: HumeClient.Options
        
        init(options: HumeClient.Options) {
            self.options = options
        }
        ${resourceNames.map((resourceName) => `public lazy var ${camelCase(resourceName)}: ${resourceName} = { ${resourceName}(options: options) }()`).join("\n")}
    }
`,
  };
};

const renderResourceClient = (
  namespaceName: string,
  resourceName: string,
  methods: SDKMethod[],
): File => {
  return {
    path: `/Sources/Hume/API/${namespaceName}/Resources/${resourceName}/${resourceName}Client.swift`,
    content: `
    import Foundation
    
    public class ${resourceName} {
        
        private let options: HumeClient.Options
        
        init(options: HumeClient.Options) {
            self.options = options
        }
        ${methods.map((method) => renderSDKMethod(method)).join("\n")}
    }
`,
  };
};

type Endpoint = {
  path: string;
  verb: Verb;
  namespace: string;
  operation: OA.OpenAPIOperation;
};

const calculateSchemaNamespaces = (
  allEndpoints: Array<Endpoint>,
  allChannels: OA.AsyncAPISpec["channels"],
): Map<string, string> => {
  const ret: Map<string, string> = new Map();
  const setNamespace = (schema: OA.JsonSchema, namespace: string) => {
    if ("schemaKey" in schema && typeof schema.schemaKey === "string") {
      ret.set(schema.schemaKey, namespace);
    }
  };

  // All 'channels' get 'empathicVoice' namespace.
  const channelNamespace = "empathicVoice";
  for (const channelPath in allChannels) {
    const channel = allChannels[channelPath];
    [channel.publish.message, channel.subscribe.message].forEach((message) => {
      walkAsyncAPIMessage(message, (m) => {
        if (m.kind === "message") {
          walkSchema(m.payload, (s) => setNamespace(s, channelNamespace));
        }
      });
    });
  }
  
  // All 'schema' objects within each channel, too.
  OA.walkObject(allChannels, (obj) => {
    if (obj && typeof obj === "object" && "kind" in obj) {
      const { data, success } = OA.JsonSchema_.safeParse(obj);
      if (success) {
        setNamespace(data, channelNamespace);
      }
    }
  });

  for (const endpoint of allEndpoints) {
    if (endpoint.operation.kind === "ignored") {
      continue;
    }
    if (endpoint.operation.kind === "jsonBody") {
      walkSchema(
        endpoint.operation.requestBody.content["application/json"].schema,
        (s) => setNamespace(s, endpoint.namespace),
      );
    }
    endpoint.operation.parameters.forEach(({ schema }) => {
      walkSchema(schema, (s) => setNamespace(s, endpoint.namespace));
    });
    Object.values(endpoint.operation.responses ?? []).forEach((response) => {
      switch (response.kind) {
        case "jsonResponse":
          walkSchema(response.content["application/json"].schema, (s) =>
            setNamespace(s, endpoint.namespace),
          );
          return;
        case "binaryResponse":
          walkSchema(response.content["audio/*"].schema, (s) =>
            setNamespace(s, endpoint.namespace),
          );
          return;
        case "noContent":
          return;
        default:
          return exhaustive(response);
      }
    });
  }
  return ret;
};

const walkAsyncAPIMessage = (
  message: OA.AsyncAPIMessage,
  f: (message: OA.AsyncAPIMessage) => void,
  visited: Set<OA.AsyncAPIMessage> = new Set(),
) => {
  f(message);
  if (message.kind === "oneOf") {
    message.oneOf.forEach((msg) => {
      if (!visited.has(msg)) {
        visited.add(msg);
        walkAsyncAPIMessage(msg, f, visited);
      }
    });
  }
};
const walkSchema = (
  root: unknown,
  f: (schema: OA.JsonSchema, path: Array<string | number>) => void,
) => {
  OA.walkObject(root, (obj, path) => {
    if (!obj || typeof obj !== "object" || !("kind" in obj)) {
      return;
    }
    const { data, success } = OA.JsonSchema_.safeParse(obj);
    if (success) {
      f(data, path);
    }
  });
};

const getNamespace = (path: string) => {
  if (path.startsWith("/v0/evi")) return "empathicVoice";
  if (path.startsWith("/v0/assistant")) return "empathicVoice"; // Map assistant paths to empathicVoice namespace
  if (path.startsWith("/v0/tts")) return "tts";
  if (path.startsWith("/chat_audio_reconstructions")) return "empathicVoice"; // Additional path mapping
  
  // Default to empathicVoice for any other paths that might be unrecognized
  console.warn(`Warning: Using default namespace for unrecognized path: ${path}`);
  return "empathicVoice";
};

const getResourceName = ({ operation, path }: Endpoint) => {
  if (operation.kind === "ignored") {
    throw new Error();
  }
  if (operation["x-fern-sdk-group-name"])
    // x-fern-sdk-group name is the name of the property that defines the "resource" that the operation belongs to
    return normalizeResourceName(operation["x-fern-sdk-group-name"]);
  if (path.startsWith("/v0/tts")) return "TTS";
  throw new Error(`Unable to determine SDK group of operation ${path}`);
};

type SwiftSDK = {
  namespaces: Record<string, {
    resourceClients: Array<{
      name: string,
      methods: SDKMethod[],
    }>,
    definitions: Array<SwiftDefinition>,
  }>
}

// Define a list of type names that need to be renamed due to collisions
// Each entry maps from original name to a Record of namespace to renamed name
const typeRenames: Record<string, Record<string, string>> = {
  "Encoding": {
    "empathicVoice": "EmpathicVoiceEncoding",
    "tts": "TTSEncoding"
  },
};

// Apply renames to a definition name based on the namespace
const applyRename = (definitionName: string, namespace: string): string => {
  if (definitionName in typeRenames) {
    // If this definition name is in our rename list and there's a specific rename for this namespace
    if (namespace in typeRenames[definitionName]) {
      return typeRenames[definitionName][namespace];
    }
  }
  return definitionName;
};

// Update references within a SwiftType to use renamed types
const updateTypeReferences = (type: SwiftType, namespace: string): SwiftType => {
  switch (type.type) {
    case "Reference":
      return { 
        type: "Reference", 
        name: applyRename(type.name, namespace)
      };
    case "Optional":
      return { 
        type: "Optional", 
        wrapped: updateTypeReferences(type.wrapped, namespace)
      };
    case "Array":
      return { 
        type: "Array", 
        element: updateTypeReferences(type.element, namespace)
      };
    case "Dictionary":
      return { 
        type: "Dictionary", 
        key: type.key, 
        value: updateTypeReferences(type.value, namespace)
      };
    default:
      return type;
  }
};

const buildSwiftSdk = (specs: OA.KnownSpecs): SwiftSDK => {
  const sdk: SwiftSDK = {
    namespaces: {},
  };
  const emptyNamespace = () => ({
    resourceClients: [],
    definitions: [],
  });
  const ensureNamespace = (namespace: string) => {
    if (!sdk.namespaces[namespace]) {
      sdk.namespaces[namespace] = emptyNamespace();
    }
  }

  const addResourceClient = (namespace: string, resourceName: string, methods: SDKMethod[]) => {
    ensureNamespace(namespace);
    sdk.namespaces[namespace].resourceClients.push({ name: resourceName, methods });
  }

  const addDefinition = (namespace: string, def: SwiftDefinition) => {
    ensureNamespace(namespace);
    sdk.namespaces[namespace].definitions.push(def);
  }

  const allEndpoints: Array<Endpoint> = [
    specs.tts,
  ]
    .flatMap((api) => {
      const pathEntries = Object.entries(api.paths);
      return pathEntries.flatMap(
        ([path, operations]: [string, Record<Verb, OA.OpenAPIOperation>]) =>
          Object.entries(operations).map(([verb, operation]) => ({
            path,
            verb: verb as Verb,
            operation,
            namespace: getNamespace(path),
          })),
      );
    })
    .filter(({ operation }) => operation.kind !== "ignored");

  const collectedByResourceName: Record<string, Array<Endpoint>> = _.groupBy(
    allEndpoints,
    getResourceName,
  );

  // Merge schemas with prefixed keys to avoid collisions
  const allSchemas: Record<string, JsonSchema> = {};
  
  // Add TTS schemas with tts: prefix for keys that might collide
  for (const [key, schema] of Object.entries(specs.tts.components.schemas)) {
    allSchemas[key] = schema;
  }
  
  // Add EVI AsyncAPI schemas with evi: prefix for keys that would collide
  for (const [key, schema] of Object.entries(specs.eviAsync.components.schemas)) {
    if (key in allSchemas) {
      // Collision detected - use prefixed key for EVI version
      const prefixedKey = `evi:${key}`;
      allSchemas[prefixedKey] = schema;
      // Update the schemaKey to maintain traceability
      (schema as any).schemaKey = prefixedKey;
    } else {
      allSchemas[key] = schema;
    }
  }
  
  console.log("All schemas containing 'Encoding':", Object.keys(allSchemas).filter(k => k.includes('Encoding')));

  const methodsByResourceName = Object.entries(collectedByResourceName).map(
    ([resourceName, endpoints]) => {
      if (endpoints.length === 0) {
        throw new Error(`No endpoints for resource ${resourceName}`);
      }
      const namespace = endpoints[0].namespace;
      assert(
        endpoints.every((x) => namespace === x.namespace),
        `Expected all endpoints to have the same namespace`,
      );
      const methods = endpoints
        .map(({ path, verb, operation }) =>
          openapiOperationToSDKMethod(
            path,
            verb,
            operation as OA.OpenAPIOperation,
            allSchemas
          ),
        )
        .filter(outNulls);
      return { namespace, resourceName, methods };
    },
  );

  methodsByResourceName.forEach(
    ({ namespace, resourceName: groupName, methods }) => {
      addResourceClient(namespace, groupName, methods);
    },
  );

  const schemaToNamespace = calculateSchemaNamespaces(
    allEndpoints,
    specs.eviAsync.channels,
  );
  
  // Explicitly set namespace for all AsyncAPI components schemas
  for (const schemaKey in specs.eviAsync.components.schemas) {
    schemaToNamespace.set(schemaKey, "empathicVoice");
  }
  
  // Explicitly set namespace for all TTS schemas
  for (const schemaKey in specs.tts.components.schemas) {
    schemaToNamespace.set(schemaKey, "tts");
  }
  
  // Set namespace for prefixed EVI schemas
  for (const schemaKey in specs.eviAsync.components.schemas) {
    if (schemaKey in specs.tts.components.schemas) {
      // This is a collision - set namespace for the prefixed version
      schemaToNamespace.set(`evi:${schemaKey}`, "empathicVoice");
    }
  }


  Object.entries(allSchemas).forEach(([name, schema]) => {
    if (schema.kind === "ignored") {
      return;
    }

    const { expr, defs } = schemaToSwiftType(schema, allSchemas);
    if (expr.type === "TODO") {
      console.warn("TODO:", name);
      return;
    }

    if (Object.keys(defs).length === 0) {
      console.error(name, schema, defs);
      throw new Error();
    }

    const namespace = schemaToNamespace.get((schema as any).schemaKey);
    if (!namespace) {
      // Special case: skip webhook-related schemas silently
      if (name.toLowerCase().includes('webhook') || name.toLowerCase().includes('webhookevent')) {
        return;
      }

      console.warn(`Warning: no namespace for schema ${name}`);
      return;
    }

    return Object.values(defs).forEach((def) => {
      if (def.name === "Encoding") {
        console.log(`Adding Encoding definition to namespace ${namespace}:`, def);
      }
      addDefinition(namespace, def);
    });
  });

  return sdk
}

const resolveNamingCollisions = (sdk: SwiftSDK): SwiftSDK => {
  // First, detect all collisions
  const nameToNamespaces: Record<string, string[]> = {};

  // Map all definition names to their namespaces
  for (const namespaceName in sdk.namespaces) {
    const namespace = sdk.namespaces[namespaceName];
    for (const definition of namespace.definitions) {
      if (!nameToNamespaces[definition.name]) {
        nameToNamespaces[definition.name] = [];
      }
      nameToNamespaces[definition.name].push(namespaceName);
    }
  }

  // Print warnings for collisions
  for (const [name, namespaces] of Object.entries(nameToNamespaces)) {
    if (namespaces.length > 1) {
      console.error(`Naming collision: '${name}' appears in namespaces: ${namespaces.join(', ')}`);
    }
  }
  
  // Create a new SDK with renamed definitions
  const newSdk: SwiftSDK = {
    namespaces: {}
  };

  // Copy structure
  for (const namespaceName in sdk.namespaces) {
    newSdk.namespaces[namespaceName] = {
      resourceClients: [],
      definitions: []
    };
  }

  // Apply renames to definitions
  for (const namespaceName in sdk.namespaces) {
    const namespace = sdk.namespaces[namespaceName];
    
    // Handle definitions - rename as needed
    for (const definition of namespace.definitions) {
      // Clone the definition to avoid mutating the original
      let newDef: SwiftDefinition;
      const newName = applyRename(definition.name, namespaceName);
      
      if (definition.type === "enum") {
        newDef = {
          ...definition,
          name: newName
        };
      } else if (definition.type === "struct") {
        // Update property types to use renamed references
        const newProperties = definition.properties.map(prop => ({
          ...prop,
          type: updateTypeReferences(prop.type, namespaceName)
        }));
        
        newDef = {
          ...definition,
          name: newName,
          properties: newProperties
        };
      } else if (definition.type === "discriminatedUnion") {
        // Update case types to use renamed references
        const newCases = definition.cases.map(c => ({
          ...c,
          type: updateTypeReferences(c.type, namespaceName)
        }));
        
        newDef = {
          ...definition,
          name: newName,
          cases: newCases
        };
      } else {
        newDef = definition; // Shouldn't happen due to exhaustive typing
      }
      
      newSdk.namespaces[namespaceName].definitions.push(newDef);
    }
    
    // Handle resource clients - update references in methods
    for (const resourceClient of namespace.resourceClients) {
      const updatedMethods = resourceClient.methods.map(method => {
        // Update parameter types
        const newParams = method.parameters.map(param => ({
          ...param,
          type: updateTypeReferences(param.type, namespaceName)
        }));
        
        // Update return type
        const newReturnType = updateTypeReferences(method.returnType, namespaceName);
        
        return {
          ...method,
          parameters: newParams,
          returnType: newReturnType
        };
      });
      
      newSdk.namespaces[namespaceName].resourceClients.push({
        name: resourceClient.name,
        methods: updatedMethods
      });
    }
  }
  
  return newSdk;
}

const detectNamingCollisions = (sdk: SwiftSDK) => {
  const allNames = new Set<string>();
  for (const namespaceName in sdk.namespaces) {
    const namespace = sdk.namespaces[namespaceName];
    for (const definition of namespace.definitions) {
      if (allNames.has(definition.name)) {
        console.error(`Naming collision: ${definition.name}`);
      }
      allNames.add(definition.name);
    }
  }
}

const clearGeneratedFiles = async () => {
  const base = __dirname + "/..";
  
  const deleteGeneratedFilesInDir = async (dirPath: string) => {
    try {
      const entries = await fs.readdir(dirPath, { withFileTypes: true });
      
      for (const entry of entries) {
        const fullPath = `${dirPath}/${entry.name}`;
        
        if (entry.isDirectory()) {
          await deleteGeneratedFilesInDir(fullPath);
        } else if (entry.isFile() && entry.name.endsWith('.swift')) {
          try {
            // Only read the first 100 bytes to check for the header
            const fileHandle = await fs.open(fullPath, 'r');
            const buffer = Buffer.alloc(100);
            const { bytesRead } = await fileHandle.read(buffer, 0, 100, 0);
            await fileHandle.close();
            
            const firstBytes = buffer.subarray(0, bytesRead).toString('utf-8');
            if (firstBytes.startsWith(GENERATION_HEADER)) {
              await fs.unlink(fullPath);
              console.log(`Deleted generated file: ${fullPath}`);
            }
          } catch (error) {
            // Ignore files that can't be read
          }
        }
      }
    } catch (error) {
      // Directory doesn't exist or can't be read, ignore
    }
  };
  
  // Delete generated files in the Sources/Hume directory
  await deleteGeneratedFilesInDir(`${base}/Sources/Hume`);
};

const writeSwiftSdk = async (sdk: SwiftSDK) => {
  const base = __dirname + "/..";
  
  // Delete all existing generated files before writing new ones
  await clearGeneratedFiles();
  
  const writeFile = async (file: File) => {
    const formatted = await swiftFormat(GENERATION_HEADER + '\n' + file.content);
    if (file.path.includes("TODO")) {
      return;
    }
    await fs.mkdir(`${base}${file.path.split("/").slice(0, -1).join("/")}`, {
      recursive: true,
    });
    await fs.writeFile(`${base}${file.path}`, formatted);
  };

  for (const namespaceName in sdk.namespaces) {
    const namespace = sdk.namespaces[namespaceName];
    await writeFile(renderNamespaceClient(namespaceName, namespace.resourceClients.map(rc => rc.name)));
    for (const resourceClient of namespace.resourceClients) {
      await writeFile(renderResourceClient(namespaceName, resourceClient.name, resourceClient.methods));
    }
    for (const definition of namespace.definitions) {
      await writeFile(renderSwiftDefinition(namespaceName, definition));
    }
  }
}

const main = async () => {
  const specs = await OA.readKnownSpecs();
  const sdk = buildSwiftSdk(specs);
  detectNamingCollisions(sdk);
  
  // Apply renames to resolve collisions
  const renamedSdk = resolveNamingCollisions(sdk);
  
  // Verify that collisions are resolved
  detectNamingCollisions(renamedSdk);
  
  await writeSwiftSdk(renamedSdk);
}

await main();
